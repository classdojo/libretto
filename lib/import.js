// Generated by CoffeeScript 1.7.0
(function() {
  var ObjectID, async, connect, fs, glob, importFixtures, insertItems, loadFixtures, mkdirp, outcome, path, readline, removeExplicit, removeReferences, stepc, traverse, validate, _log, _types;

  stepc = require("stepc");

  outcome = require("outcome");

  async = require("async");

  mkdirp = require("mkdirp");

  glob = require("glob");

  fs = require("fs");

  readline = require("readline");

  path = require("path");

  traverse = require("traverse");

  validate = require("./validate");

  connect = require("./connect");

  ObjectID = require("mongodb").ObjectID;

  _log = require("./log");

  _types = {
    ObjectID: ObjectID,
    Date: Date
  };


  /*
   */

  module.exports = function(options, next) {
    var o, _ref;
    o = outcome.e(next);
    process.env.LOG_LIBRETTO = (_ref = options.verbose) != null ? _ref : process.env.LOG_LIBRETTO;
    return stepc.async((function() {
      return validate(options, this);
    }), o.s(function() {
      return connect({
        db: options.db
      }, this);
    }), o.s(function(db) {
      this.db = db;
      return this();
    }), o.s(function() {
      return glob(options.path, this);
    }), o.s(function(collectionFiles) {
      collectionFiles = collectionFiles.filter(function(name) {
        return !/.DS_Store/.test(name) && /(json|js)$/.test(name);
      });
      console.log(collectionFiles);
      return importFixtures(collectionFiles, this.db, this);
    }), next);
  };


  /*
   */

  importFixtures = function(fixturePaths, db, next) {
    var o;
    o = outcome.e(next);
    return stepc.async((function() {
      return loadFixtures(fixturePaths, this);
    }), o.s(function(items) {
      this.items = items;
      return removeReferences(db, items, this);
    }), o.s(function() {
      return removeExplicit(db, this.items, this);
    }), o.s(function() {
      return insertItems(db, this.items, this);
    }), next);
  };

  loadFixtures = function(fixturePaths, next) {
    var items;
    items = [];
    return async.eachSeries(fixturePaths, (function(fixturePath, next) {
      items = items.concat(require(fixturePath));
      return next();
    }), outcome.e(next).s(function() {
      return next(null, items.map(function(item) {
        traverse(item.data).forEach(function(x) {
          if (x && x.__type) {
            return this.update(new _types[x.__type](x.value));
          }
        });
        return item;
      }));
    }));
  };

  removeExplicit = function(db, items, next) {
    var rm;
    rm = items.filter(function(item) {
      return item.method === "remove";
    });
    return async.eachSeries(rm, (function(item, next) {
      _log("remove %s %s", item.collection, JSON.stringify(item.query));
      return db.collection(item.collection).remove(item.query, next);
    }), next);
  };

  removeReferences = function(db, items, next) {
    return async.eachSeries(items, function(item, next) {
      var collection, keys, refs;
      refs = [];
      for (collection in item.refs) {
        keys = item.refs[collection];
        refs.push.apply(refs, keys.map(function(key) {
          return {
            collection: collection,
            field: key
          };
        }));
      }
      return async.eachSeries(refs, (function(ref, next) {
        var search;
        search = {};
        search[ref.field] = item.data._id;
        _log("remove %s:%s.%s", ref.collection, item.data._id, ref.field);
        return db.collection(ref.collection).remove(search, next);
      }), next);
    }, next);
  };


  /*
   */

  insertItems = function(db, items, next) {
    items = items.filter(function(item) {
      return item.method === "insert";
    });
    async.eachSeries(items, (function(item, next) {
      if (/^system/.test(item.collection)) {
        return next();
      }
      _log("insert %s:%s", item.collection, item.data._id);
      return db.collection(item.collection).insert(item.data, function(err) {
        if (err) {
          console.warn(err);
        }
        return next();
      });
    }), next);
    return function(fixturePath, next) {
      var collectionName, results;
      collectionName = path.basename(fixturePath).split(".").shift();
      _log("importing %s", collectionName);
      results = require(fixturePath);
      return importItems(results, db, next);
    };
  };

}).call(this);
