// Generated by CoffeeScript 1.7.0
(function() {
  var async, attachRefs, attachRefs2, connect, exportCollection, exportCollections, fs, loadCollections, mapItemRelationships, mkdirp, mongodb, outcome, stepc, traverse, type, validate, _log;

  stepc = require("stepc");

  outcome = require("outcome");

  async = require("async");

  mkdirp = require("mkdirp");

  fs = require("fs");

  type = require("type-component");

  traverse = require("traverse");

  validate = require("./validate");

  connect = require("./connect");

  mongodb = require("mongodb");

  _log = require("./log");


  /*
   */

  module.exports = function(options, next) {
    var o;
    o = outcome.e(next);
    return stepc.async((function() {
      return validate(options, this);
    }), o.s(function() {
      var e;
      try {
        mkdirp.sync(options.path);
      } catch (_error) {
        e = _error;
      }
      return this();
    }), o.s(function() {
      return connect({
        db: options.db
      }, this);
    }), o.s(function(db) {
      this.db = db;
      return db.collectionNames(this);
    }), o.s(function(names) {
      var collections;
      collections = names.map((function(_this) {
        return function(data) {
          return _this.db.collection(data.name.split(".").slice(1).join("."));
        };
      })(this));
      return exportCollections(options, collections, this);
    }), next);
  };


  /*
   */

  exportCollections = function(options, collections, next) {
    return loadCollections(collections, function(err, collections) {
      mapItemRelationships(collections);
      return async.eachSeries(collections, exportCollection(options), next);
    });
  };


  /*
   */

  mapItemRelationships = function(collections) {
    var all, collection, item, key, _i, _j, _len, _len1, _ref, _results;
    _log("mapping item relationships");
    all = {};
    for (_i = 0, _len = collections.length; _i < _len; _i++) {
      collection = collections[_i];
      _ref = collection.items;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        item = _ref[_j];
        all[item.data._id] = item;
      }
    }
    _results = [];
    for (key in all) {
      item = all[key];
      _results.push(attachRefs(item, all, collections));
    }
    return _results;
  };

  attachRefs = function(item, all) {
    var keys;
    keys = [];
    return traverse(item.data).forEach(function(x) {
      var key, p, r, ref, refs;
      keys = [];
      p = this;
      while (p) {
        if (isNaN(p.key) && p.key) {
          keys.unshift(p.key);
        }
        p = p.parent;
      }
      key = keys.join(".");
      if (ref = all[x]) {
        refs = ref.refs;
        if (!(r = refs[item.collection])) {
          r = refs[item.collection] = [];
        }
        if (!~r.indexOf(key)) {
          r.push(key);
        }
      }
      if (x && typeof x === "object" && !/^(Array|Object)$/.test(x.constructor.name)) {
        this.update({
          __type: x.constructor.name,
          value: x
        });
        return this.block();
      }
    });
  };


  /*
   */

  attachRefs2 = function(item, all, current, keys) {
    var key, kp, r, ref, refs, sub, t, value, _i, _len;
    if (keys == null) {
      keys = [];
    }
    if (!current) {
      current = item;
    }
    for (key in current) {
      value = current[key];
      if ((ref = all[value])) {
        kp = keys.concat(key).join(".");
        refs = ref.__refs;
        if (!(r = refs[item.__collection])) {
          r = refs[item.__collection] = [];
        }
        if (!~r.indexOf(kp)) {
          r.push(kp);
        }
      } else if ((t = type(value)) === "array") {
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          sub = value[_i];
          if (sub) {
            attachRefs(item, all, sub, keys.concat(key));
          }
        }
      } else if (t === "object" && value) {
        attachRefs(item, all, value, keys.concat());
      }
      if (value && (typeof value === "object") && !/^Array|Object$/.test(value.constructor.name)) {
        current[key] = {
          __type: value.constructor.name,
          value: value
        };
      }
    }
    return refs;
  };


  /*
   */

  loadCollections = function(collections, next) {
    var data;
    data = [];
    return async.eachSeries(collections, (function(collection, next) {
      return collection.find().toArray(function(err, result) {
        if (err != null) {
          return next(err);
        }
        _log("loaded %s (%d)", collection.collectionName, result.length);
        data.push({
          name: collection.collectionName,
          items: result.map(function(item) {
            return {
              data: item,
              collection: collection.collectionName,
              refs: {},
              method: "insert"
            };
          })
        });
        return next();
      });
    }), function(err) {
      if (err != null) {
        return next(err);
      }
      return next(null, data);
    });
  };


  /*
   */

  exportCollection = function(options) {
    return function(collection, next) {
      var o, path;
      path = options.path + "/" + collection.name + ".json";
      _log("exporting %s", collection.name);
      o = outcome.e(next);
      if (collection.items.length === 0) {
        return next();
      }
      return stepc.async(o.s(function(results) {
        return fs.writeFile(path, JSON.stringify(collection.items, null, 2), this);
      }), next);
    };
  };

}).call(this);
